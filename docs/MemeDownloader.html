<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Meme Downloader</title>
  <link rel="stylesheet" href="./css/MemeDownloader.css">
  <script src="./js/MemeDownloader/StreamSaver.min.js"></script>
  <script src="./js/MemeDownloader/ponyfill.min.js"></script>

  <script src="./js/MemeDownloader/vue.global.js"></script>
  <script src="./js/MemeDownloader/jszip.min.js"></script>
  <script src="./js/MemeDownloader/FileSaver.min.js"></script>
  <script src="./js/MemeDownloader/MemeDownloader.js"></script>
</head>
<footer style="position: fixed; top: 20px; right: 20px; text-align: right; font-size: 14px; color: #666;">
  <p style="margin: 0; line-height: 1.5;">
    &copy; 2025<br>
    MIT License<br>
    <a href="https://github.com/shangxueink/koishi-shangxue-apps/issues" target="_blank"
      style="color: #6200ea; text-decoration: none;">é—®é¢˜åé¦ˆ</a>
    <br>
    <a href="https://shangxueink.github.io/koishi-shangxue-apps/"
      style="color: #6200ea; text-decoration: none;">è¿”å›æ–‡æ¡£</a>
  </p>
</footer>

<body>
  <div id="app">
    <h1>Meme Downloader</h1>
    <div id="description">
      <p>é€‚ç”¨äº <a
          href="https://greasyfork.org/zh-CN/scripts/521666-bilibili%E4%B8%93%E6%A0%8F%E5%8E%9F%E5%9B%BE%E9%93%BE%E6%8E%A5%E6%8F%90%E5%8F%962024%E6%94%B9%E7%89%88"
          target="_blank">bilibiliä¸“æ é“¾æ¥æå–è„šæœ¬</a> çš„ä¸‹è½½å™¨å“¦</p>
      <h3>ä½¿ç”¨è¯´æ˜ ğŸ“–</h3>
      <ol>
        <li><strong>å‹¾é€‰éœ€è¦ä¸‹è½½çš„è¡¨æƒ…åŒ…</strong> âœ…ï¼Œç„¶åç‚¹å‡»ä¸‹æ–¹çš„ã€ä¸‹è½½ã€‘æŒ‰é’®ã€‚</li>
        <li><strong>åŒå‡»å›¾ç‰‡</strong>ï¼šåˆ‡æ¢é¢„è§ˆå›¾ ğŸ”„</li>
        <li><strong>å•å‡»å›¾ç‰‡</strong>ï¼šæŸ¥çœ‹å¤§å›¾ ğŸ”</li>
        <li>
          <strong>é€€å‡ºå¤§å›¾æ¨¡å¼</strong>ï¼š
          <ul>
            <li>æŒ‰ <code>ESC</code> é”®ã€‚</li>
            <li>æˆ–ç‚¹å‡»å³ä¸Šè§’çš„å‰å·ï¼ˆÃ—ï¼‰ã€‚</li>
            <li>æˆ–å†æ¬¡å•å‡»ä»»æ„å¤„ã€‚</li>
          </ul>
        </li>
      </ol>
      <hr>
      <h3>æ³¨æ„ âš ï¸</h3>
      <ul>
        <li>å¦‚æœæµè§ˆå™¨æç¤ºï¼ˆé€šå¸¸åœ¨å·¦ä¸Šè§’ï¼‰<strong>"æ­¤æ–‡ä»¶æƒ³è¦ä¸‹è½½å¤šä¸ªæ–‡ä»¶"</strong>ï¼Œè¯·ç‚¹å‡»<strong>å…è®¸</strong>ã€‚</li>
        <li>ä¸‹è½½çš„è¡¨æƒ…æ–‡ä»¶å°†ä¿å­˜åˆ°å½“å‰ <strong>æµè§ˆå™¨çš„é»˜è®¤ä¸‹è½½æ–‡ä»¶å¤¹</strong> ğŸ“ï¼Œå›¾ç‰‡æ–‡ä»¶å°†å­˜æ”¾åˆ° <code>è¡¨æƒ…åŒ…åç§°.zip</code> çš„æ–‡ä»¶ä¸­ã€‚</li>
      </ul>
      <hr>
      <p>å¦‚æœä½ å¸Œæœ›ä¸‹è½½è‡ªå·±æ•´ç†çš„TXTå†…å®¹</p>
      <p>è¯·ç‚¹å‡»æœ€ä¸‹æ–¹çš„ã€åŠ å·ã€‘æŒ‰é’®ï¼Œå¹¶ç²˜è´´æˆ–ä¸Šä¼ å¯¹åº”çš„TXTå†…å®¹ ğŸ“ã€‚</p>
      <hr>
      <p>å†æ¬¡æé†’ï¼šæœ¬é¡¹ç›®ä¸‹è½½ç»“æœæ˜¯ è‹¥å¹²ä¸ªå‹ç¼©åŒ…ï¼Œå¹¶ä¸æ˜¯ç›´æ¥è¿”å›å›¾ç‰‡</p>

      <button id="selectAllBtn" @click="toggleSelectAll">å…¨éƒ¨å‹¾é€‰</button>
    </div>

    <div id="loading" v-if="loading">
      <div style="font-size: 24px; color: #6200ea;">åŠ è½½ä¸­...</div>
    </div>
    <div id="book-list">
      <div v-for="book in books" :key="book.name" class="book-item"
        :class="{ 'selected': selectedBooks.includes(book.name) }" @click="toggleSelect(book)">
        <img :src="book.cover" :alt="book.name" referrerpolicy="no-referrer" @click.stop="handleImageClick(book)"
          @dblclick.stop="changeCover(book)">
        <label>{{ book.name.replace('.txt', '') }}</label>
        <input type="checkbox" :value="book.name" v-model="selectedBooks">
        <div class="checkbox-custom"></div>
      </div>

      <div class="book-item add-emoji" @click="showAddEmojiModal">
        <span>+</span>
      </div>
    </div>


    <div class="progress-container" id="progressContainer">
      <div v-for="task in activeTasks" :key="task.book" class="progress-item">
        <div class="title">{{ task.book.replace('.txt', '') }}</div>
        <progress :value="task.completed" :max="task.total"></progress>
        <div class="status">å·²ä¸‹è½½: {{ task.completed }}/{{ task.total }}</div>
      </div>
    </div>
    <button id="actionBtn" @click="startDownload">ä¸‹è½½ ({{ selectedBooks.length }})</button>
    <div class="download-controls" id="downloadControls" v-if="hasActiveTasks">
      <button class="pause" @click="pauseDownload" v-if="!isPaused">æš‚åœä¸‹è½½</button>
      <button class="resume" @click="resumeDownload" v-if="isPaused">ç»§ç»­ä¸‹è½½</button>
      <button class="stop" @click="stopDownload">ç»“æŸä¸‹è½½</button>
    </div>

    <div id="imageModal" v-if="showModal" @click="closeModal">
      <button id="closeImageModal" @click.stop="closeModal">Ã—</button>
      <img id="modalImage" :src="modalImageSrc" alt="Large preview" referrerpolicy="no-referrer">
    </div>

    <div class="modal" v-if="showAddEmojiModalFlag">
      <div class="modal-header">æ·»åŠ è¡¨æƒ…åŒ…</div>
      <div class="modal-content">
        <textarea placeholder="ç›´æ¥ç²˜è´´TXTå†…å®¹...è¯·ä¿æŒä¸€è¡Œä¸€ä¸ªå›¾ç‰‡é“¾æ¥" v-model="newEmojiContent"></textarea>
        <label class="file-upload" for="file-upload">
          <span>ğŸ“ ä¸Šä¼ TXTæ–‡ä»¶</span>
        </label>
        <input type="file" id="file-upload" @change="handleFileUpload" accept=".txt">
      </div>
      <div class="modal-actions">
        <button class="confirm" @click="addEmoji">ç¡®è®¤</button>
        <button class="cancel" @click="closeAddEmojiModal">å–æ¶ˆ</button>
      </div>
    </div>
  </div>
  <script>
    const { createApp, ref, computed, watch, onMounted, onUnmounted } = Vue;
    createApp({
      setup() {
        const books = ref([]);
        const selectedBooks = ref([]);
        const loading = ref(true);
        const downloadTasks = ref(new Map());
        const isPaused = ref(false);
        const showModal = ref(false);
        const modalImageSrc = ref('');
        const showAddEmojiModalFlag = ref(false);
        const newEmojiContent = ref('');
        const activeTasks = computed(() => Array.from(downloadTasks.value.values()).filter(task => task.isDownloading));

        const hasActiveTasks = computed(() => activeTasks.value.length > 0);

        const toggleSelectAll = () => {
          const allChecked = books.value.every(book => selectedBooks.value.includes(book.name));
          selectedBooks.value = allChecked ? [] : books.value.map(book => book.name);
        };

        const toggleSelect = (book) => {
          const index = selectedBooks.value.indexOf(book.name);
          if (index === -1) {
            selectedBooks.value.push(book.name);
          } else {
            selectedBooks.value.splice(index, 1);
          }
        };

        const handleImageClick = (book) => {
          if (!book.clickTimer) {
            book.clickTimer = setTimeout(() => {
              showLargeImage(book);
              book.clickTimer = null; // æ¸…é™¤è®¡æ—¶å™¨
            }, 300); // å»¶è¿Ÿä¸€ç§’è§¦å‘å•å‡»
          } else {
            clearTimeout(book.clickTimer); // æ¸…é™¤å•å‡»è®¡æ—¶å™¨
            book.clickTimer = null;
            changeCover(book); // è§¦å‘åŒå‡»
          }
        };

        const showLargeImage = (book) => {
          modalImageSrc.value = book.cover;
          showModal.value = true;
        };

        const changeCover = async (book) => {
          if (book.isChangingCover) return; // å¦‚æœæ­£åœ¨åˆ‡æ¢ï¼Œç›´æ¥è¿”å›
          book.isChangingCover = true; // æ ‡è®°ä¸ºæ­£åœ¨åˆ‡æ¢

          const lines = book.content.split('\n').filter(line => line.trim() !== '');
          const randomIndex = Math.floor(Math.random() * lines.length);
          const newCover = processUrl(lines[randomIndex]);

          try {
            const response = await fetch(newCover, {
              headers: {
                'Referer': 'https://www.bilibili.com/',
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36'
              },
              referrerPolicy: 'no-referrer'
            });

            if (!response.ok) {
              throw new Error('Network response was not ok');
            }

            const blob = await response.blob();
            const objectURL = URL.createObjectURL(blob);
            book.cover = objectURL;
          } catch (error) {
            console.error('Failed to load image:', newCover, error);
          } finally {
            book.isChangingCover = false; // é‡ç½®æ ‡è®°
          }
        };


        const closeModal = () => {
          showModal.value = false;
        };

        const handleEscapeKey = (event) => {
          if (event.key === 'Escape') {
            closeModal();
          }
        };

        onMounted(async () => {
          loading.value = true;
          try {
            const loadedBooks = await createMockBooks();
            books.value = loadedBooks;
          } catch (error) {
            console.error("Failed to load mockBooks:", error);
          } finally {
            loading.value = false;
          }
          window.addEventListener('keydown', handleEscapeKey);
        });

        onMounted(() => {
          window.addEventListener('keydown', handleEscapeKey);
        });

        onUnmounted(() => {
          window.removeEventListener('keydown', handleEscapeKey);
        });

        const showAddEmojiModal = () => {
          showAddEmojiModalFlag.value = true;
        };

        const closeAddEmojiModal = () => {
          showAddEmojiModalFlag.value = false;
        };

        const handleFileUpload = (event) => {
          const file = event.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
              newEmojiContent.value = e.target.result;
            };
            reader.readAsText(file);
          }
        };

        const generateUniqueName = (existingNames) => {
          let name;
          do {
            const randomNum = Math.floor(Math.random() * 1000);
            name = `Meme_${randomNum}`;
          } while (existingNames.includes(name));
          return name;
        };

        const loadCoverFromContent = (content) => {
          const lines = content.split('\n').filter(line => line.trim() !== '');
          if (lines.length === 0) {
            return 'https://i0.hdslb.com/bfs/article/80d629bf90808e63331132e644bfb441927f896d.png'; // é»˜è®¤å°é¢
          }
          const randomIndex = Math.floor(Math.random() * lines.length);
          return processUrl(lines[randomIndex]);
        };

        const addEmoji = () => {
          if (newEmojiContent.value) {
            const existingNames = books.value.map(book => book.name);
            const newEmojiName = generateUniqueName(existingNames) + '.txt';
            const newEmoji = {
              name: newEmojiName,
              cover: loadCoverFromContent(newEmojiContent.value), // ä½¿ç”¨å‡½æ•°è®¾ç½®cover
              content: newEmojiContent.value
            };
            books.value.push(newEmoji);
            newEmojiContent.value = ''; // æ¸…ç©ºå†…å®¹
            closeAddEmojiModal();
          }
        };



        const startDownload = () => {
          if (selectedBooks.value.length === 0) {
            alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªè¡¨æƒ…åŒ…è¿›è¡Œä¸‹è½½ã€‚');
            return;
          }
          selectedBooks.value.forEach(bookName => {
            startBookDownload(bookName);
          });

          // è‡ªåŠ¨è§¦å‘ä¸€æ¬¡æš‚åœå’Œç»§ç»­
          pauseDownload();
          setTimeout(() => {
            resumeDownload();
          }, 100);
        };

        const startBookDownload = (bookName) => {
          const book = books.value.find(b => b.name === bookName);
          if (!book) {
            console.error(`Book ${bookName} not found.`);
            return;
          }

          const content = book.content;
          const lines = content.split('\n').filter(line => line.trim() !== '');
          const total = lines.length;

          const task = {
            book: bookName,
            completed: 0,
            total: total,
            isDownloading: true,
            isPaused: false,
            currentLine: 0,
            lines: lines,
            zip: new JSZip()
          };
          downloadTasks.value.set(bookName, task);
        };

        const pauseDownload = () => {
          downloadTasks.value.forEach(task => {
            if (task.isDownloading) {
              task.isPaused = true;
            }
          });
          isPaused.value = true;
        };

        const resumeDownload = () => {
          isPaused.value = false;
          downloadTasks.value.forEach(task => {
            if (task.isPaused) {
              task.isPaused = false;
              processDownload(task);
            }
          });
        };

        const processDownload = async (task) => {
          const maxConcurrent = 15; // å¹¶è¡Œä¸‹è½½æ•°
          const bookName = task.book.replace('.txt', '');
          let currentLine = 0;
          let completed = 0;
          let isDownloading = true;
          let isPaused = false;

          // åˆå§‹åŒ– StreamSaver
          if (typeof streamSaver === 'undefined') {
            alert('StreamSaver is not defined. Make sure it is loaded correctly.');
            return;
          }

          const fileStream = streamSaver.createWriteStream(`${bookName}.zip`);
          const writer = fileStream.getWriter();
          const encoder = new TextEncoder(); // ç”¨äºå°†å­—ç¬¦ä¸²è½¬æ¢ä¸º Uint8Array

          try {
            while (currentLine < task.lines.length && isDownloading && !isPaused) {
              const batchSize = Math.min(maxConcurrent, task.lines.length - currentLine);
              const downloadPromises = [];

              for (let i = 0; i < batchSize; i++) {
                const line = task.lines[currentLine + i].trim();
                if (line) {
                  const url = processUrl(line);
                  const imageName = `${bookName}_${extractFilenameFromUrl(url)}`;

                  const downloadPromise = (async () => {
                    try {
                      const response = await fetch(url, {
                        headers: {
                          'Referer': 'https://www.bilibili.com/',
                          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36'
                        },
                        referrerPolicy: 'no-referrer'
                      });

                      if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                      }

                      const blob = await response.blob();
                      const arrayBuffer = await blob.arrayBuffer();
                      const uint8Array = new Uint8Array(arrayBuffer);

                      // æ„å»º ZIP æ–‡ä»¶æ¡ç›®çš„å¤´éƒ¨å’Œå†…å®¹
                      const zipEntryHeader = createZipEntryHeader(imageName, uint8Array.length);
                      const zipEntryData = new Uint8Array([...zipEntryHeader, ...uint8Array]);

                      // å†™å…¥æµ
                      await writer.write(zipEntryData);

                      completed++;
                      task.completed = completed; // æ›´æ–°ä»»åŠ¡è¿›åº¦

                      // æ›´æ–°å‰ç«¯è¿›åº¦ 
                      // è¿™é‡Œå¯ä»¥è°ƒæ•´æ›´æ–°é¢‘ç‡
                      if (completed % 5 === 0) {
                        console.log(`Downloaded: ${completed}/${task.lines.length}`);
                      }
                    } catch (error) {
                      console.error(`Error downloading ${url}: ${error.message}`);
                    }
                  })();

                  downloadPromises.push(downloadPromise);
                }
              }

              await Promise.all(downloadPromises);
              currentLine += batchSize;
            }

            // æ·»åŠ  ZIP æ–‡ä»¶ç»“æŸæ ‡è¯†
            const zipEnd = createZipEnd();
            await writer.write(zipEnd);

            // å…³é—­æµ
            await writer.close();
            isDownloading = false;
            downloadTasks.value.delete(task.book);
            // alert(`${bookName}.zip ä¸‹è½½å®Œæˆï¼`);

          } catch (error) {
            console.error('StreamSaver error:', error);
            alert('ä¸‹è½½è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ï¼');
          } finally {
            task.isDownloading = false;
            await writer.close();
          }
        };

        // åˆ›å»º ZIP æ–‡ä»¶æ¡ç›®å¤´éƒ¨
        function createZipEntryHeader(filename, fileSize) {
          const filenameBytes = new TextEncoder().encode(filename);
          const header = new Uint8Array(30 + filenameBytes.length);

          let offset = 0;
          // Local file header signature
          header[offset++] = 0x50; header[offset++] = 0x4B; header[offset++] = 0x03; header[offset++] = 0x04;
          // Version needed to extract
          header[offset++] = 0x14; header[offset++] = 0x00;
          // General purpose bit flag
          header[offset++] = 0x00; header[offset++] = 0x00;
          // Compression method (0 for stored)
          header[offset++] = 0x00; header[offset++] = 0x00;
          // Last mod file time
          header[offset++] = 0x00; header[offset++] = 0x00;
          // Last mod file date
          header[offset++] = 0x00; header[offset++] = 0x00;
          // CRC-32 (dummy value, will be calculated later)
          header[offset++] = 0x00; header[offset++] = 0x00; header[offset++] = 0x00; header[offset++] = 0x00;
          // Compressed size
          header[offset++] = fileSize & 0xFF; header[offset++] = (fileSize >> 8) & 0xFF; header[offset++] = (fileSize >> 16) & 0xFF; header[offset++] = (fileSize >> 24) & 0xFF;
          // Uncompressed size
          header[offset++] = fileSize & 0xFF; header[offset++] = (fileSize >> 8) & 0xFF; header[offset++] = (fileSize >> 16) & 0xFF; header[offset++] = (fileSize >> 24) & 0xFF;
          // Filename length
          header[offset++] = filenameBytes.length & 0xFF; header[offset++] = (filenameBytes.length >> 8) & 0xFF;
          // Extra field length
          header[offset++] = 0x00; header[offset++] = 0x00;

          // Filename
          for (let i = 0; i < filenameBytes.length; i++) {
            header[offset++] = filenameBytes[i];
          }

          return header;
        }

        // åˆ›å»º ZIP æ–‡ä»¶ç»“æŸæ ‡è¯†
        function createZipEnd() {
          const end = new Uint8Array(22);
          let offset = 0;

          // End of central directory signature
          end[offset++] = 0x50; end[offset++] = 0x4B; end[offset++] = 0x05; end[offset++] = 0x06;
          // Number of this disk
          end[offset++] = 0x00; end[offset++] = 0x00;
          // Number of the disk with the start of the central directory
          end[offset++] = 0x00; end[offset++] = 0x00;
          // Total number of entries in the central directory on this disk
          end[offset++] = 0x00; end[offset++] = 0x00;
          // Total number of entries in the central directory
          end[offset++] = 0x00; end[offset++] = 0x00;
          // Size of the central directory
          end[offset++] = 0x00; end[offset++] = 0x00; end[offset++] = 0x00; end[offset++] = 0x00;
          // Offset of start of central directory with respect to the starting disk number
          end[offset++] = 0x00; end[offset++] = 0x00; end[offset++] = 0x00; end[offset++] = 0x00;
          // Comment length
          end[offset++] = 0x00; end[offset++] = 0x00;

          return end;
        }


        const stopDownload = () => {
          downloadTasks.value.forEach(task => {
            task.isDownloading = false;
            task.isPaused = false;
          });
          downloadTasks.value.clear();
          isPaused.value = false;
        };




        const processUrl = (url) => {
          return url.startsWith('http') ? url : 'https://i0.hdslb.com/bfs/' + url;
        };

        const extractFilenameFromUrl = (url) => {
          const urlObj = new URL(url);
          const pathname = urlObj.pathname;
          const parts = pathname.split('/');
          return parts[parts.length - 1];
        };


        const startImageDownloads = async (task) => {
          const bookName = task.book;
          const zip = task.zip; // ä» task ä¸­è·å– zip å®ä¾‹

          while (task.currentLine < task.lines.length && task.isDownloading) {
            if (task.isPaused) {
              await new Promise(resolve => setTimeout(resolve, 100)); // æš‚åœæ—¶ç­‰å¾…
              continue;
            }
            const line = task.lines[task.currentLine].trim();
            if (line) {
              const url = processUrl(line);
              const imageName = `${bookName.replace('.txt', '')}_${extractFilenameFromUrl(url)}`;
              try {
                const blob = await downloadImage(url);
                zip.file(imageName, blob);
                task.completed++;
              } catch (error) {
                console.error(`Error downloading ${url}: ${error.message}`);
              }
            }
            task.currentLine++;
          }

          if (task.currentLine >= task.lines.length) {
            task.isDownloading = false;
            downloadTasks.value.delete(bookName);

            // ä¸‹è½½ ZIP æ–‡ä»¶
            zip.generateAsync({ type: "blob" }).then(function (content) {
              saveAs(content, `${bookName.replace('.txt', '')}.zip`);
            });
          }
        };

        const downloadImage = async (url) => {
          try {
            const response = await fetch(url, {
              headers: {
                'Referer': 'https://www.bilibili.com/',
                'User-Agent': 'Mozilla / 5.0 (Windows NT 10.0; Win64; x64) AppleWebKit / 537.36 (KHTML, like Gecko) Chrome / 92.0.4515.131 Safari / 537.36'
              },
              referrerPolicy: 'no-referrer'
            });
            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
            const blob = await response.blob();
            return blob; // è¿”å› Blob å¯¹è±¡
          } catch (error) {
            console.error(`Error downloading image: ${url}`, error);
            throw error;
          }
        };


        return {
          books,
          selectedBooks,
          loading,
          downloadTasks,
          isPaused,
          showModal,
          modalImageSrc,
          showAddEmojiModalFlag,
          activeTasks,
          hasActiveTasks,
          newEmojiContent,
          toggleSelectAll,
          toggleSelect,
          handleImageClick,
          changeCover,
          closeModal,
          showAddEmojiModal,
          closeAddEmojiModal,
          handleFileUpload,
          addEmoji,
          startDownload,
          pauseDownload,
          resumeDownload,
          stopDownload
        };

      }
    }).mount('#app');
  </script>
</body>

</html>