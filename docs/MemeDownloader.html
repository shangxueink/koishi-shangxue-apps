<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Meme Downloader</title>
  <link rel="stylesheet" href="./css/MemeDownloader.css">
  <script src="./js/MemeDownloader/StreamSaver.min.js"></script>
  <script src="./js/MemeDownloader/ponyfill.min.js"></script>
  <script src="./js/MemeDownloader/fflate.umd.index.js"></script>

  <script src="./js/MemeDownloader/vue.global.js"></script>
  <script src="./js/MemeDownloader/jszip.min.js"></script>
  <script src="./js/MemeDownloader/MemeDownloader.js"></script>
</head>
<footer style="position: fixed; top: 20px; right: 20px; text-align: right; font-size: 14px; color: #666;">
  <p style="margin: 0; line-height: 1.5;">
    &copy; 2025<br>
    MIT License<br>
    <a href="https://github.com/shangxueink/koishi-shangxue-apps/issues" target="_blank"
      style="color: #6200ea; text-decoration: none;">é—®é¢˜åé¦ˆ</a>
    <br>
    <a href="https://shangxueink.github.io/koishi-shangxue-apps/"
      style="color: #6200ea; text-decoration: none;">è¿”å›æ–‡æ¡£</a>
  </p>
</footer>

<body>
  <div id="app">
    <h1>Meme Downloader</h1>
    <div id="description">
      <p>é€‚ç”¨äº <a
          href="https://greasyfork.org/zh-CN/scripts/521666-bilibili%E4%B8%93%E6%A0%8F%E5%8E%9F%E5%9B%BE%E9%93%BE%E6%8E%A5%E6%8F%90%E5%8F%962024%E6%94%B9%E7%89%88"
          target="_blank">bilibiliä¸“æ é“¾æ¥æå–è„šæœ¬</a> çš„ä¸‹è½½å™¨å“¦</p>
      <h3>ä½¿ç”¨è¯´æ˜ ğŸ“–</h3>
      <ol>
        <li><strong>å‹¾é€‰éœ€è¦ä¸‹è½½çš„è¡¨æƒ…åŒ…</strong> âœ…ï¼Œç„¶åç‚¹å‡»ä¸‹æ–¹çš„ã€ä¸‹è½½ã€‘æŒ‰é’®ã€‚</li>
        <li><strong>åŒå‡»å›¾ç‰‡</strong>ï¼šåˆ‡æ¢é¢„è§ˆå›¾ ğŸ”„</li>
        <li><strong>å•å‡»å›¾ç‰‡</strong>ï¼šæŸ¥çœ‹å¤§å›¾ ğŸ”</li>
        <li>
          <strong>é€€å‡ºå¤§å›¾æ¨¡å¼</strong>ï¼š
          <ul>
            <li>æŒ‰ <code>ESC</code> é”®ã€‚</li>
            <li>æˆ–ç‚¹å‡»å³ä¸Šè§’çš„å‰å·ï¼ˆÃ—ï¼‰ã€‚</li>
            <li>æˆ–å†æ¬¡å•å‡»ä»»æ„å¤„ã€‚</li>
          </ul>
        </li>
      </ol>
      <hr>
      <h3>æ³¨æ„ âš ï¸</h3>
      <ul>
        <li>å¦‚æœæµè§ˆå™¨æç¤ºï¼ˆé€šå¸¸åœ¨å·¦ä¸Šè§’ï¼‰<strong>"æ­¤æ–‡ä»¶æƒ³è¦ä¸‹è½½å¤šä¸ªæ–‡ä»¶"</strong>ï¼Œè¯·ç‚¹å‡»<strong>å…è®¸</strong>ã€‚</li>
        <li>ä¸‹è½½çš„è¡¨æƒ…æ–‡ä»¶å°†ä¿å­˜åˆ°å½“å‰ <strong>æµè§ˆå™¨çš„é»˜è®¤ä¸‹è½½æ–‡ä»¶å¤¹</strong> ğŸ“ï¼Œå›¾ç‰‡æ–‡ä»¶å°†å­˜æ”¾åˆ° <code>è¡¨æƒ…åŒ…åç§°.zip</code> çš„æ–‡ä»¶ä¸­ã€‚</li>
      </ul>
      <hr>
      <p>å¦‚æœä½ å¸Œæœ›ä¸‹è½½è‡ªå·±æ•´ç†çš„TXTå†…å®¹</p>
      <p>è¯·ç‚¹å‡»æœ€ä¸‹æ–¹çš„ã€åŠ å·ã€‘æŒ‰é’®ï¼Œå¹¶ç²˜è´´æˆ–ä¸Šä¼ å¯¹åº”çš„TXTå†…å®¹ ğŸ“ã€‚</p>
      <hr>
      <p>âš ï¸ ä¸è¦å…¨é€‰ä¸‹è½½ï¼Œè¿™å¯èƒ½ä¼šå¯¼è‡´æµè§ˆå™¨å ç”¨è¿‡å¤šçš„èµ„æºï¼ˆç½‘ç»œè¯·æ±‚ã€å¤„ç†æ–‡ä»¶ã€æ‰“åŒ…zip...ï¼‰ã€‚</p>
      <button id="selectAllBtn" @click="toggleSelectAll">å…¨éƒ¨å‹¾é€‰</button>
    </div>

    <div id="loading" v-if="loading">
      <div style="font-size: 24px; color: #6200ea;">åŠ è½½ä¸­...</div>
    </div>
    <div id="book-list">
      <div v-for="book in books" :key="book.name" class="book-item"
        :class="{ 'selected': selectedBooks.includes(book.name) }" @click="toggleSelect(book)">
        <img :src="book.cover" :alt="book.name" referrerpolicy="no-referrer" @click.stop="handleImageClick(book)"
          @dblclick.stop="changeCover(book)">
        <label>{{ book.name.replace('.txt', '') }}</label>
        <input type="checkbox" :value="book.name" v-model="selectedBooks">
        <div class="checkbox-custom"></div>
      </div>

      <div class="book-item add-emoji" @click="showAddEmojiModal">
        <span>+</span>
      </div>
    </div>


    <div class="progress-container" id="progressContainer">
      <div v-for="task in activeTasks" :key="task.book" class="progress-item">
        <div class="title">{{ task.book.replace('.txt', '') }}</div>
        <progress :value="task.completed" :max="task.total"></progress>
        <div class="status">å·²ä¸‹è½½: {{ task.completed }}/{{ task.total }}</div>
      </div>
    </div>
    <button id="actionBtn" @click="startDownload">ä¸‹è½½ ({{ selectedBooks.length }})</button>
    <div class="download-controls" id="downloadControls" v-if="hasActiveTasks">
      <button class="pause" @click="pauseDownload" v-if="!isPaused">æš‚åœä¸‹è½½</button>
      <button class="resume" @click="resumeDownload" v-if="isPaused">ç»§ç»­ä¸‹è½½</button>
      <button class="stop" @click="stopDownload">ç»“æŸä¸‹è½½</button>
    </div>

    <div id="imageModal" v-if="showModal" @click="closeModal">
      <button id="closeImageModal" @click.stop="closeModal">Ã—</button>
      <img id="modalImage" :src="modalImageSrc" alt="Large preview" referrerpolicy="no-referrer">
    </div>

    <div class="modal" v-if="showAddEmojiModalFlag">
      <div class="modal-header">æ·»åŠ è¡¨æƒ…åŒ…</div>
      <div class="modal-content">
        <textarea placeholder="ç›´æ¥ç²˜è´´TXTå†…å®¹...è¯·ä¿æŒä¸€è¡Œä¸€ä¸ªå›¾ç‰‡é“¾æ¥" v-model="newEmojiContent"></textarea>
        <label class="file-upload" for="file-upload">
          <span>ğŸ“ ä¸Šä¼ TXTæ–‡ä»¶</span>
        </label>
        <input type="file" id="file-upload" @change="handleFileUpload" accept=".txt">
      </div>
      <div class="modal-actions">
        <button class="confirm" @click="addEmoji">ç¡®è®¤</button>
        <button class="cancel" @click="closeAddEmojiModal">å–æ¶ˆ</button>
      </div>
    </div>
  </div>
  <script>
    const { createApp, ref, computed, watch, onMounted, onUnmounted } = Vue;
    createApp({
      setup() {
        const books = ref([]);
        const selectedBooks = ref([]);
        const loading = ref(true);
        const downloadTasks = ref(new Map());
        const isPaused = ref(false);
        const showModal = ref(false);
        const modalImageSrc = ref('');
        const showAddEmojiModalFlag = ref(false);
        const newEmojiContent = ref('');
        const activeTasks = computed(() => Array.from(downloadTasks.value.values()).filter(task => task.isDownloading));

        const hasActiveTasks = computed(() => activeTasks.value.length > 0);

        const toggleSelectAll = () => {
          const allChecked = books.value.every(book => selectedBooks.value.includes(book.name));
          selectedBooks.value = allChecked ? [] : books.value.map(book => book.name);
        };

        const toggleSelect = (book) => {
          const index = selectedBooks.value.indexOf(book.name);
          if (index === -1) {
            selectedBooks.value.push(book.name);
          } else {
            selectedBooks.value.splice(index, 1);
          }
        };

        const handleImageClick = (book) => {
          if (!book.clickTimer) {
            book.clickTimer = setTimeout(() => {
              showLargeImage(book);
              book.clickTimer = null; // æ¸…é™¤è®¡æ—¶å™¨
            }, 300); // å»¶è¿Ÿä¸€ç§’è§¦å‘å•å‡»
          } else {
            clearTimeout(book.clickTimer); // æ¸…é™¤å•å‡»è®¡æ—¶å™¨
            book.clickTimer = null;
            changeCover(book); // è§¦å‘åŒå‡»
          }
        };

        const showLargeImage = (book) => {
          modalImageSrc.value = book.cover;
          showModal.value = true;
        };

        const changeCover = async (book) => {
          if (book.isChangingCover) return; // å¦‚æœæ­£åœ¨åˆ‡æ¢ï¼Œç›´æ¥è¿”å›
          book.isChangingCover = true; // æ ‡è®°ä¸ºæ­£åœ¨åˆ‡æ¢

          const lines = book.content.split('\n').filter(line => line.trim() !== '');
          const randomIndex = Math.floor(Math.random() * lines.length);
          const newCover = processUrl(lines[randomIndex]);

          try {
            const response = await fetch(newCover, {
              headers: {
                'Referer': 'https://www.bilibili.com/',
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36'
              },
              referrerPolicy: 'no-referrer'
            });

            if (!response.ok) {
              throw new Error('Network response was not ok');
            }

            const blob = await response.blob();
            const objectURL = URL.createObjectURL(blob);
            book.cover = objectURL;
          } catch (error) {
            console.error('Failed to load image:', newCover, error);
          } finally {
            book.isChangingCover = false; // é‡ç½®æ ‡è®°
          }
        };


        const closeModal = () => {
          showModal.value = false;
        };

        const handleEscapeKey = (event) => {
          if (event.key === 'Escape') {
            closeModal();
          }
        };

        onMounted(async () => {
          loading.value = true;
          try {
            const loadedBooks = await createMockBooks();
            books.value = loadedBooks;
          } catch (error) {
            console.error("Failed to load mockBooks:", error);
          } finally {
            loading.value = false;
          }
          window.addEventListener('keydown', handleEscapeKey);
        });

        onMounted(() => {
          window.addEventListener('keydown', handleEscapeKey);
        });

        onUnmounted(() => {
          window.removeEventListener('keydown', handleEscapeKey);
        });

        const showAddEmojiModal = () => {
          showAddEmojiModalFlag.value = true;
        };

        const closeAddEmojiModal = () => {
          showAddEmojiModalFlag.value = false;
        };

        const handleFileUpload = (event) => {
          const file = event.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
              newEmojiContent.value = e.target.result;
            };
            reader.readAsText(file);
          }
        };

        const generateUniqueName = (existingNames) => {
          let name;
          do {
            const randomNum = Math.floor(Math.random() * 1000);
            name = `Meme_${randomNum}`;
          } while (existingNames.includes(name));
          return name;
        };

        const loadCoverFromContent = (content) => {
          const lines = content.split('\n').filter(line => line.trim() !== '');
          if (lines.length === 0) {
            return 'https://i0.hdslb.com/bfs/article/80d629bf90808e63331132e644bfb441927f896d.png'; // é»˜è®¤å°é¢
          }
          const randomIndex = Math.floor(Math.random() * lines.length);
          return processUrl(lines[randomIndex]);
        };

        const addEmoji = () => {
          if (newEmojiContent.value) {
            const existingNames = books.value.map(book => book.name);
            const newEmojiName = generateUniqueName(existingNames) + '.txt';
            const newEmoji = {
              name: newEmojiName,
              cover: loadCoverFromContent(newEmojiContent.value), // ä½¿ç”¨å‡½æ•°è®¾ç½®cover
              content: newEmojiContent.value
            };
            books.value.push(newEmoji);
            newEmojiContent.value = ''; // æ¸…ç©ºå†…å®¹
            closeAddEmojiModal();
          }
        };



        const startDownload = () => {
          if (selectedBooks.value.length === 0) {
            alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªè¡¨æƒ…åŒ…è¿›è¡Œä¸‹è½½ã€‚');
            return;
          }
          selectedBooks.value.forEach(bookName => {
            startBookDownload(bookName);
          });

          // è‡ªåŠ¨è§¦å‘ä¸€æ¬¡æš‚åœå’Œç»§ç»­
          pauseDownload();
          setTimeout(() => {
            resumeDownload();
          }, 100);
        };

        const startBookDownload = (bookName) => {
          const book = books.value.find(b => b.name === bookName);
          if (!book) {
            console.error(`Book ${bookName} not found.`);
            return;
          }

          const content = book.content;
          const lines = content.split('\n').filter(line => line.trim() !== '');
          const total = lines.length;

          const task = {
            book: bookName,
            completed: 0,
            total: total,
            isDownloading: true,
            isPaused: false,
            currentLine: 0,
            lines: lines,
            zip: new JSZip()
          };
          downloadTasks.value.set(bookName, task);
        };

        const pauseDownload = () => {
          downloadTasks.value.forEach(task => {
            if (task.isDownloading) {
              task.isPaused = true;
            }
          });
          isPaused.value = true;
        };

        const resumeDownload = () => {
          isPaused.value = false;
          downloadTasks.value.forEach(task => {
            if (task.isPaused) {
              task.isPaused = false;
              processDownload(task);
            }
          });
        };

        const processDownload = async (task) => {
          const MAX_CONCURRENT = 50; // æœ€å¤§å¹¶è¡Œä¸‹è½½æ•°
          const BATCH_SIZE = 150; // æ¯ä¸ªZIPæ–‡ä»¶åŒ…å«çš„å›¾ç‰‡æ•°é‡
          const bookName = task.book.replace('.txt', '');

          try {
            // æ´»è·ƒä¸‹è½½è®¡æ•°å™¨
            let activeDownloads = 0;
            let nextLineIndex = 0;
            let completed = 0;
            let currentBatch = 1;
            let currentBatchFiles = {};
            let currentBatchCount = 0;

            // è·Ÿè¸ªZIPåˆ›å»ºçŠ¶æ€ï¼Œé˜²æ­¢é‡å¤åˆ›å»º
            let isCreatingZip = false;
            // è·Ÿè¸ªå·²åˆ›å»ºçš„æ‰¹æ¬¡
            const processedBatches = new Set();

            // è·å–URLä¸­çš„æ–‡ä»¶æ‰©å±•å
            const getFileExtension = (url) => {
              try {
                // ä»URLä¸­æå–æ–‡ä»¶åéƒ¨åˆ†
                const fileName = url.split('/').pop();
                // ä»æ–‡ä»¶åä¸­æå–æ‰©å±•å
                const match = fileName.match(/\.([a-zA-Z0-9]+)($|\?)/);
                // å¦‚æœæ‰¾åˆ°æ‰©å±•åï¼Œè¿”å›å®ƒï¼Œå¦åˆ™é»˜è®¤ä¸ºjpg
                return match ? match[1].toLowerCase() : 'jpg';
              } catch (error) {
                console.warn(`æ— æ³•ä»URLè·å–æ‰©å±•å: ${url}`, error);
                return 'jpg'; // é»˜è®¤æ‰©å±•å
              }
            };

            // ä¸‹è½½é€Ÿåº¦ç›‘æ§
            let lastBytes = 0;
            let totalBytes = 0;
            const speedMonitor = setInterval(() => {
              const currentBytes = Object.values(currentBatchFiles).reduce((sum, arr) => sum + arr.length, 0);
              const newBytes = currentBytes - lastBytes;
              totalBytes += newBytes;
              const speedMBps = (newBytes / 1024 / 1024).toFixed(2);
              console.log(`ä¸‹è½½é€Ÿåº¦: ${speedMBps} MB/s, æ´»è·ƒä¸‹è½½: ${activeDownloads}, å·²å®Œæˆ: ${completed}/${task.lines.length}, å½“å‰æ‰¹æ¬¡: ${currentBatch}`);
              lastBytes = currentBytes;
            }, 1000);

            // åˆ›å»ºZIPå¹¶ä¸‹è½½
            const createAndDownloadZip = async (batchFiles, batchNum) => {
              // æ£€æŸ¥æ­¤æ‰¹æ¬¡æ˜¯å¦å·²å¤„ç†
              if (processedBatches.has(batchNum)) {
                console.log(`æ‰¹æ¬¡ #${batchNum} å·²å¤„ç†ï¼Œè·³è¿‡`);
                return;
              }

              // æ ‡è®°æ­¤æ‰¹æ¬¡ä¸ºå·²å¤„ç†
              processedBatches.add(batchNum);

              console.log(`Creating ZIP batch #${batchNum} with ${Object.keys(batchFiles).length} files`);

              // åˆ›å»ºæ–‡ä»¶æµ
              const fileStream = streamSaver.createWriteStream(`${bookName}_part${batchNum}.zip`);
              const writer = fileStream.getWriter();

              try {
                // ä½¿ç”¨ Promise åŒ…è£… fflate.zip å›è°ƒ
                await new Promise((resolve, reject) => {
                  fflate.zip(batchFiles, { level: 1 }, (err, data) => {
                    if (err) {
                      console.error('ZIP error:', err);
                      reject(err);
                      return;
                    }

                    // å†™å…¥æ•°æ®
                    writer.write(new Uint8Array(data.buffer));
                    console.log(`Wrote ${(data.length / 1024 / 1024).toFixed(2)} MB to ZIP part ${batchNum}`);

                    // å…³é—­å†™å…¥æµ
                    writer.close();
                    console.log(`ZIP part ${batchNum} completed`);
                    resolve();
                  });
                });
              } catch (error) {
                console.error(`Error creating ZIP part ${batchNum}:`, error);
                writer.abort();
              }
            };

            // æ£€æŸ¥å¹¶åˆ›å»ºZIPæ‰¹æ¬¡çš„å‡½æ•°
            const checkAndCreateZip = async () => {
              // å¦‚æœå½“å‰æ­£åœ¨åˆ›å»ºZIPï¼Œæˆ–è€…å½“å‰æ‰¹æ¬¡æ²¡æœ‰è¶³å¤Ÿçš„æ–‡ä»¶ï¼Œåˆ™è¿”å›
              if (isCreatingZip || currentBatchCount < BATCH_SIZE) {
                return;
              }

              // æ ‡è®°æ­£åœ¨åˆ›å»ºZIP
              isCreatingZip = true;

              try {
                // åˆ›å»ºå½“å‰æ‰¹æ¬¡çš„ZIP
                const batchToProcess = { ...currentBatchFiles };
                const batchNumToProcess = currentBatch;

                // é‡ç½®å½“å‰æ‰¹æ¬¡
                currentBatchFiles = {};
                currentBatchCount = 0;
                currentBatch++;

                // åˆ›å»ºå¹¶ä¸‹è½½ZIP
                await createAndDownloadZip(batchToProcess, batchNumToProcess);
              } finally {
                // å®Œæˆåé‡ç½®æ ‡è®°
                isCreatingZip = false;

                // æ£€æŸ¥æ˜¯å¦æœ‰æ–°çš„æ‰¹æ¬¡éœ€è¦å¤„ç†
                if (currentBatchCount >= BATCH_SIZE) {
                  // é€’å½’è°ƒç”¨ä»¥å¤„ç†ä¸‹ä¸€ä¸ªæ‰¹æ¬¡
                  setTimeout(checkAndCreateZip, 0);
                }
              }
            };

            // ä¸‹è½½å•ä¸ªæ–‡ä»¶çš„å‡½æ•°
            const downloadFile = async (lineIndex) => {
              if (lineIndex >= task.lines.length || task.isPaused || !task.isDownloading) {
                activeDownloads--;
                return;
              }

              activeDownloads++;
              const line = task.lines[lineIndex].trim();

              if (!line) {
                activeDownloads--;
                // å¦‚æœå½“å‰è¡Œä¸ºç©ºï¼Œç«‹å³å¤„ç†ä¸‹ä¸€è¡Œ
                if (nextLineIndex < task.lines.length) {
                  downloadFile(nextLineIndex++);
                }
                return;
              }

              const url = processUrl(line);
              // è·å–æ–‡ä»¶æ‰©å±•å
              const fileExtension = getFileExtension(url);
              // ä½¿ç”¨æ­£ç¡®çš„æ‰©å±•ååˆ›å»ºæ–‡ä»¶å
              const imageName = `${bookName}_${lineIndex}.${fileExtension}`;

              try {
                const controller = new AbortController();

                // æ·»åŠ å–æ¶ˆç›‘å¬å™¨
                const cancelListener = () => {
                  if (task.isPaused || !task.isDownloading) {
                    controller.abort();
                  }
                };

                // æ¯100msæ£€æŸ¥ä¸€æ¬¡æ˜¯å¦éœ€è¦å–æ¶ˆ
                const cancelInterval = setInterval(cancelListener, 100);

                const response = await fetch(url, {
                  headers: {
                    'Referer': 'https://www.bilibili.com/',
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36'
                  },
                  referrerPolicy: 'no-referrer',
                  signal: controller.signal
                });

                clearInterval(cancelInterval);

                if (!response.ok) {
                  throw new Error(`HTTP error! status: ${response.status}`);
                }

                const blob = await response.blob();

                // å¦‚æœContent-Typeå¯ç”¨ï¼Œå¯ä»¥è¿›ä¸€æ­¥éªŒè¯æ–‡ä»¶ç±»å‹
                const contentType = response.headers.get('Content-Type');
                if (contentType && !contentType.includes(`image/${fileExtension}`) &&
                  fileExtension !== 'jpg' && contentType.includes('image/')) {
                  // è®°å½•ä¸åŒ¹é…çš„æƒ…å†µï¼Œä½†ä¸æ”¹å˜æ‰©å±•åï¼Œå› ä¸ºURLä¸­çš„æ‰©å±•åé€šå¸¸æ˜¯æ­£ç¡®çš„
                  console.log(`è­¦å‘Š: å†…å®¹ç±»å‹ ${contentType} ä¸URLæ‰©å±•å .${fileExtension} ä¸åŒ¹é…ï¼ŒURL: ${url}`);
                }

                const arrayBuffer = await blob.arrayBuffer();
                const uint8Array = new Uint8Array(arrayBuffer);

                // å°†æ–‡ä»¶æ·»åŠ åˆ°å½“å‰æ‰¹æ¬¡
                currentBatchFiles[imageName] = uint8Array;
                currentBatchCount++;

                completed++;
                task.completed = completed;

                // æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ›å»ºä¸€ä¸ªZIPæ‰¹æ¬¡
                if (currentBatchCount >= BATCH_SIZE) {
                  // è§¦å‘ZIPåˆ›å»ºæ£€æŸ¥
                  checkAndCreateZip();
                }

              } catch (error) {
                if (error.name === 'AbortError') {
                  console.log(`Download of ${url} was aborted`);
                } else {
                  console.error(`Error downloading ${url}: ${error.message}`);
                }
              } finally {
                activeDownloads--;

                // å…³é”®éƒ¨åˆ†ï¼šå½“ä¸€ä¸ªä¸‹è½½å®Œæˆåï¼Œç«‹å³å¼€å§‹ä¸‹ä¸€ä¸ª
                if (nextLineIndex < task.lines.length && !task.isPaused && task.isDownloading) {
                  downloadFile(nextLineIndex++);
                }

                // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ä¸‹è½½éƒ½å·²å®Œæˆ
                if (activeDownloads === 0 && nextLineIndex >= task.lines.length) {
                  finishDownload();
                }
              }
            };

            // å®Œæˆä¸‹è½½çš„å‡½æ•°
            const finishDownload = async () => {
              clearInterval(speedMonitor);

              if (task.isPaused) {
                console.log('Download paused');
                return;
              }

              // å¤„ç†æœ€åä¸€ä¸ªæ‰¹æ¬¡ï¼ˆå¦‚æœæœ‰æ–‡ä»¶ï¼‰
              if (currentBatchCount > 0 && !processedBatches.has(currentBatch)) {
                await createAndDownloadZip(currentBatchFiles, currentBatch);
              }

              console.log(`å…¨éƒ¨ä¸‹è½½å®Œæˆï¼Œå…± ${completed} ä¸ªæ–‡ä»¶ï¼Œåˆ†ä¸º ${processedBatches.size} ä¸ªZIPåŒ…`);

              task.isDownloading = false;
              downloadTasks.value.delete(task.book);
            };

            // åˆå§‹å¯åŠ¨ä¸‹è½½ä»»åŠ¡ï¼Œæœ€å¤šå¯åŠ¨MAX_CONCURRENTä¸ª
            const initialBatch = Math.min(MAX_CONCURRENT, task.lines.length);
            for (let i = 0; i < initialBatch; i++) {
              downloadFile(nextLineIndex++);
            }

            // ç­‰å¾…æ‰€æœ‰ä¸‹è½½å®Œæˆ
            await new Promise(resolve => {
              const checkInterval = setInterval(() => {
                if (activeDownloads === 0 && (nextLineIndex >= task.lines.length || task.isPaused || !task.isDownloading)) {
                  clearInterval(checkInterval);
                  resolve();
                }
              }, 500);
            });

            // å¦‚æœæ²¡æœ‰åœ¨finishDownloadä¸­å¤„ç†ï¼Œè¿™é‡Œå†æ¬¡è°ƒç”¨
            if (activeDownloads === 0 && !task.isPaused && task.isDownloading) {
              await finishDownload();
            }

          } catch (error) {
            console.error('Download error:', error);
            alert('ä¸‹è½½è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ï¼');
            task.isDownloading = false;
            clearInterval(speedMonitor);
          }
        };


        const stopDownload = () => {
          downloadTasks.value.forEach(task => {
            task.isDownloading = false;
            task.isPaused = false;
          });
          downloadTasks.value.clear();
          isPaused.value = false;
        };




        const processUrl = (url) => {
          return url.startsWith('http') ? url : 'https://i0.hdslb.com/bfs/' + url;
        };

        const extractFilenameFromUrl = (url) => {
          const urlObj = new URL(url);
          const pathname = urlObj.pathname;
          const parts = pathname.split('/');
          return parts[parts.length - 1];
        };


        const startImageDownloads = async (task) => {
          const bookName = task.book;
          const zip = task.zip; // ä» task ä¸­è·å– zip å®ä¾‹

          while (task.currentLine < task.lines.length && task.isDownloading) {
            if (task.isPaused) {
              await new Promise(resolve => setTimeout(resolve, 100)); // æš‚åœæ—¶ç­‰å¾…
              continue;
            }
            const line = task.lines[task.currentLine].trim();
            if (line) {
              const url = processUrl(line);
              const imageName = `${bookName.replace('.txt', '')}_${extractFilenameFromUrl(url)}`;
              try {
                const blob = await downloadImage(url);
                zip.file(imageName, blob);
                task.completed++;
              } catch (error) {
                console.error(`Error downloading ${url}: ${error.message}`);
              }
            }
            task.currentLine++;
          }

          if (task.currentLine >= task.lines.length) {
            task.isDownloading = false;
            downloadTasks.value.delete(bookName);

            // ä¸‹è½½ ZIP æ–‡ä»¶
            zip.generateAsync({ type: "blob" }).then(function (content) {
              saveAs(content, `${bookName.replace('.txt', '')}.zip`);
            });
          }
        };

        const downloadImage = async (url) => {
          try {
            const response = await fetch(url, {
              headers: {
                'Referer': 'https://www.bilibili.com/',
                'User-Agent': 'Mozilla / 5.0 (Windows NT 10.0; Win64; x64) AppleWebKit / 537.36 (KHTML, like Gecko) Chrome / 92.0.4515.131 Safari / 537.36'
              },
              referrerPolicy: 'no-referrer'
            });
            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
            const blob = await response.blob();
            return blob; // è¿”å› Blob å¯¹è±¡
          } catch (error) {
            console.error(`Error downloading image: ${url}`, error);
            throw error;
          }
        };


        return {
          books,
          selectedBooks,
          loading,
          downloadTasks,
          isPaused,
          showModal,
          modalImageSrc,
          showAddEmojiModalFlag,
          activeTasks,
          hasActiveTasks,
          newEmojiContent,
          toggleSelectAll,
          toggleSelect,
          handleImageClick,
          changeCover,
          closeModal,
          showAddEmojiModal,
          closeAddEmojiModal,
          handleFileUpload,
          addEmoji,
          startDownload,
          pauseDownload,
          resumeDownload,
          stopDownload
        };

      }
    }).mount('#app');
  </script>
</body>

</html>